package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	generate "github.com/rur/ttgen"
	writers "github.com/rur/ttgen/writers"
)

var generateUsage = `
Usage: ttroutes ./routemap.yml ./routes.go.templ ./routes.go
Write a routes file from routemap yaml. This will overwrite an existing file at the destination


`

var genheader = `
// Code generated by go generate; DO NOT EDIT.

// This file was created by github.com/rur/ttgen/cmd/ttroutes
// Map file: %s
// Template file: %s
// Local time: %s

%s
`

func main() {
	if len(os.Args) < 4 {
		fmt.Printf(generateUsage)
		return
	}
	yamlPath := os.Args[1]

	data, err := ioutil.ReadFile(yamlPath)
	if err != nil {
		fmt.Printf("Error loading routemap file: %v", err)
		return
	}
	routemap, err := generate.LoadSitemap(data)
	if err != nil {
		fmt.Printf("Error parsing routemap YAML: %v", err)
		return
	}

	templPath := os.Args[2]
	templData, err := ioutil.ReadFile(templPath)
	if err != nil {
		fmt.Printf("Error loading routes template file: %v", err)
		return
	}
	// prefix routes template with generator heading
	routesTempl := fmt.Sprintf(
		genheader,
		yamlPath,
		templPath,
		time.Now().Format("Mon Jan _2 15:04:05 2006"),
		string(templData),
	)

	destPath := os.Args[3]
	if !strings.HasSuffix(destPath, ".go") {
		log.Fatalf("Expecting destinationÂ files with .go suffix, got '%s'", destPath)
	}
	destDir := filepath.Dir(destPath)
	destFile := filepath.Base(destPath)

	for _, def := range routemap.Pages {
		pageName, err := writers.SanitizeName(def.Page)
		if err != nil {
			log.Fatalf("Invalid page name '%s': %s", def.Page, err)
		}

		_, err = writers.WriteRoutesFile(destDir, destFile, &def, routemap.Namespace, pageName, routesTempl)
		if err != nil {
			log.Fatalf("Error creating routes.go file for '%s'. %s", def.Page, err)
			return
		}

		break // only load the first page
	}
	if err != nil {
		log.Fatalf("Treetop: Failed to build routes.go for routemap %s\n Error: %s\n", destPath, err.Error())
		return
	} else {
		// attempt to format the go code
		// this should not cause the generate command to fail if go fmt fails for some reason
		var fmtError []string

		cmd := exec.Command("go", "fmt", destPath)
		output, err := cmd.CombinedOutput()
		if err != nil {
			fmtError = append(fmtError, fmt.Sprintf("%s Error: %s\nOutput: %s", destPath, err, string(output)))
		}
		if len(fmtError) > 0 {
			log.Fatalf(
				"Generated folder but `go fmt` failed for the following files:\n\t%s",
				strings.Join(fmtError, "\n\t"),
			)
		}
	}
}
